From d044e3549933de51d59931fc4047a92a71c9c809 Mon Sep 17 00:00:00 2001
From: Ritesh Raj Sarraf <rrs@researchut.com>
Date: Wed, 2 Feb 2011 19:51:46 +0530
Subject: [PATCH 1/3] add -r to make resulting device read-only

This patch adds the ability to create targets which are read-only to
keep from accidentally modifying the newly created device.  In some cases,
mounting with -o ro still modifies the device (in the case of ext3
filesystems).  I created a small patch that will do this.  I have tested it
only to the point that using -a with or without -r produces the desired
effects.

Signed-off-by: Ritesh Raj Sarraf <rsarraf@netapp.com>
Signed-off-by: Wakko Warner <wakko@animx.eu.org>
---
 kpartx/devmapper.c |    5 ++++-
 kpartx/devmapper.h |    2 +-
 kpartx/kpartx.c    |   12 ++++++++----
 3 files changed, 13 insertions(+), 6 deletions(-)

diff --git a/kpartx/devmapper.c b/kpartx/devmapper.c
index f884511..7ebc5b6 100644
--- a/kpartx/devmapper.c
+++ b/kpartx/devmapper.c
@@ -81,7 +81,7 @@ dm_simplecmd (int task, const char *name, int no_flush, uint32_t *cookie) {
 
 extern int
 dm_addmap (int task, const char *name, const char *target,
-	   const char *params, uint64_t size, const char *uuid, int part,
+	   const char *params, uint64_t size, int ro, const char *uuid, int part,
 	   mode_t mode, uid_t uid, gid_t gid, uint32_t *cookie) {
 	int r = 0;
 	struct dm_task *dmt;
@@ -96,6 +96,9 @@ dm_addmap (int task, const char *name, const char *target,
 	if (!dm_task_add_target (dmt, 0, size, target, params))
 		goto addout;
 
+	if (ro && !dm_task_set_ro (dmt))
+			goto addout;
+
 	if (task == DM_DEVICE_CREATE && uuid) {
 		prefixed_uuid = malloc(MAX_PREFIX_LEN + strlen(uuid) + 1);
 		if (!prefixed_uuid) {
diff --git a/kpartx/devmapper.h b/kpartx/devmapper.h
index f8692cc..6226129 100644
--- a/kpartx/devmapper.h
+++ b/kpartx/devmapper.h
@@ -5,7 +5,7 @@
 int dm_prereq (char *, int, int, int);
 int dm_simplecmd (int, const char *, int, uint32_t *);
 int dm_addmap (int, const char *, const char *, const char *, uint64_t,
-	       const char *, int, mode_t, uid_t, gid_t, uint32_t *);
+	       int, const char *, int, mode_t, uid_t, gid_t, uint32_t *);
 int dm_map_present (char *);
 char * dm_mapname(int major, int minor);
 dev_t dm_get_first_dep(char *devname);
diff --git a/kpartx/kpartx.c b/kpartx/kpartx.c
index 3d33990..f518aa0 100644
--- a/kpartx/kpartx.c
+++ b/kpartx/kpartx.c
@@ -82,7 +82,7 @@ initpts(void)
 	addpts("sun", read_sun_pt);
 }
 
-static char short_opts[] = "ladgvp:t:s";
+static char short_opts[] = "rladgvp:t:s";
 
 /* Used in gpt.c */
 int force_gpt=0;
@@ -91,6 +91,7 @@ static int
 usage(void) {
 	printf("usage : kpartx [-a|-d|-l] [-v] wholedisk\n");
 	printf("\t-a add partition devmappings\n");
+	printf("\t-r devmappings will be readonly\n");
 	printf("\t-d del partition devmappings\n");
 	printf("\t-l list partitions devmappings that would be added by -a\n");
 	printf("\t-p set device name-partition number delimiter\n");
@@ -185,7 +186,7 @@ get_hotplug_device(void)
 
 int
 main(int argc, char **argv){
-	int fd, i, j, m, n, op, off, arg, c, d;
+	int fd, i, j, m, n, op, off, arg, c, d, ro=0;
 	struct slice all;
 	struct pt *ptp;
 	enum action what = LIST;
@@ -233,6 +234,9 @@ main(int argc, char **argv){
 	}
 
 	while ((arg = getopt(argc, argv, short_opts)) != EOF) switch(arg) {
+		case 'r':
+			ro=1;
+			break;
 		case 'g':
 			force_gpt=1;
 			break;
@@ -470,7 +474,7 @@ main(int argc, char **argv){
 					DM_DEVICE_RELOAD : DM_DEVICE_CREATE);
 
 				if (!dm_addmap(op, partname, DM_TARGET, params,
-					       slices[j].size, uuid, j+1,
+					       slices[j].size, ro, uuid, j+1,
 					       buf.st_mode & 0777, buf.st_uid,
 					       buf.st_gid, &cookie)) {
 					fprintf(stderr, "create/reload failed on %s\n",
@@ -536,7 +540,7 @@ main(int argc, char **argv){
 					      DM_DEVICE_RELOAD : DM_DEVICE_CREATE);
 
 					dm_addmap(op, partname, DM_TARGET, params,
-						  slices[j].size, uuid, j+1,
+						  slices[j].size, ro, uuid, j+1,
 						  buf.st_mode & 0777,
 						  buf.st_uid, buf.st_gid,
 						  &cookie);
-- 
1.7.2.3

